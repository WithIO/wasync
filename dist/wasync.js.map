{"version":3,"sources":["webpack://wasync/webpack/universalModuleDefinition","webpack://wasync/webpack/bootstrap","webpack://wasync/./src/debounce.js","webpack://wasync/./src/index.js"],"names":["DEFAULT_WAIT","DEFAULT_PROP","INACTIVE","WAITING","RUNNING","Debounce","wait","self","state","next","undefined","timeout","func","validate","prepare","run","success","failure","cleanup","Error","stack","this","args","arguments","hooks","params","this_","v","apply","clearTimeout","setTimeout","prom","Promise","resolve","call","e","reject","then","catch","finally","ObjectDebounce","prop","deb"],"mappings":"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","file":"wasync.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wasync\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wasync\"] = factory();\n\telse\n\t\troot[\"wasync\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","const DEFAULT_WAIT = 300;\nconst DEFAULT_PROP = '$wasyncDebounce';\n\nconst INACTIVE = 1;\nconst WAITING = 2;\nconst RUNNING = 3;\n\n\n/**\n * Implements the Async Debounce pattern.\n *\n * It helps you call asynchronous functions only once at a time.\n *\n * See the README\n *\n * @param wait {number} Milliseconds to wait before running\n * @constructor\n */\nexport function Debounce({wait = DEFAULT_WAIT} = {}) {\n    const self = this;\n\n    self.state = INACTIVE;\n    self.next = undefined;\n    self.timeout = null;\n\n    /**\n     * Generates an asynchronously debounced function\n     *\n     * @param validate {function} Validation function. If the return value is\n     *                            false-ish then the operation is canceled,\n     *                            otherwise the return value is passed as first\n     *                            parameter of run()\n     * @param prepare {function} Immediately invoked in order to prepare the\n     *                           UI for the imminent load (like enable the\n     *                           loader)\n     * @param run {function} The function that does the action. It can return\n     *                       a promise. It will be called with the output of\n     *                       validate() after wait milliseconds\n     * @param success {function} Called with the value returned/resolved by\n     *                           run() in case of success\n     * @param failure {function} Called with the exception/rejection value\n     *                           raised by run()\n     * @param cleanup {function} Does the opposite of prepare(), when all\n     *                           is finished\n     * @returns {Function} Returned function is a composition of all provided\n     *                     hooks, in such a way that each of the hook is called\n     *                     exactly when it should be (according to the logic\n     *                     explained in the README).\n     */\n    self.func = function ({\n        validate,\n        prepare,\n        run,\n        success,\n        failure,\n        cleanup,\n    }) {\n        if (!run) {\n            throw new Error(\n                '\"run\" function is not defined! That is the point of this '\n                + 'Debounce class, so you probably are doing something wrong',\n            );\n        }\n\n        return function () {\n            const stack = {\n                this: this,\n                args: arguments,\n                hooks: {\n                    validate,\n                    prepare,\n                    run,\n                    success,\n                    failure,\n                    cleanup,\n                },\n            };\n\n            stack.params = self.validate(stack);\n\n            if (!stack.params) {\n                return;\n            }\n\n            if (self.state === INACTIVE) {\n                self.prepare(stack);\n            }\n\n            self.next = stack;\n\n            if (self.state !== RUNNING) {\n                self.wait();\n            }\n        };\n    };\n\n    /**\n     * Runs the validation hook. If no hook is provided then just return an\n     * empty object.\n     *\n     * @private\n     * @param validate {function|undefined} Validation hook\n     * @param this_ {object} Object to bind the validation hook to\n     * @param args {array} Arguments to call the function with\n     */\n    self.validate = function ({hooks: {validate}, this: this_, args}) {\n        let v = {};\n\n        if (validate) {\n            v = validate.apply(this_, args);\n        }\n\n        return v;\n    };\n\n    /**\n     * Runs the prepare hook, if defined\n     *\n     * @private\n     * @param prepare {function|undefined} Prepare hook\n     * @param this_ {object} Object to bind the prepare hook to\n     */\n    self.prepare = function ({hooks: {prepare}, this: this_}) {\n        if (prepare) {\n            prepare.apply(this_);\n        }\n    };\n\n    /**\n     * Go into waiting state and call the run function after the given amount\n     * of time. If a timeout was already running, cancel it.\n     *\n     * @private\n     */\n    self.wait = function () {\n        self.state = WAITING;\n\n        clearTimeout(self.timeout);\n        self.timeout = setTimeout(function () {\n            self.run();\n        }, wait);\n    };\n\n    /**\n     * Runs the run hook, wait for the result and then trigger the finishing\n     * sequence (re-run if new run available, otherwise success/failure hooks\n     * then cleanup).\n     *\n     * It is expected that the run hook might not always return a Promise, or\n     * might just return a Promise-like but with not the exact API we need. For\n     * this reason, it passes through Promise.resolve()/Promise.reject().\n     *\n     * @private\n     */\n    self.run = function () {\n        self.state = RUNNING;\n\n        const stack = this.next;\n        const {\n            this: this_,\n            params,\n            hooks: {\n                run,\n                success,\n                failure,\n                cleanup,\n            },\n        } = stack;\n\n        let prom;\n\n        try {\n            prom = Promise.resolve(run.call(this_, params));\n        } catch (e) {\n            prom = Promise.reject(e);\n        }\n\n        prom\n            .then(function () {\n                if (success) {\n                    success.apply(this_, arguments);\n                }\n            })\n            .catch(function () {\n                if (failure) {\n                    failure.apply(this_, arguments);\n                }\n            })\n            .finally(() => {\n                if (self.next === stack) {\n                    try {\n                        if (cleanup) {\n                            cleanup.apply(this_);\n                        }\n                    } finally {\n                        self.state = INACTIVE;\n                    }\n                } else {\n                    setTimeout(() => self.run(), 0);\n                }\n            });\n    };\n}\n\n\n/**\n * Independently of how you define your \"classes\" in JS ('cause you got a hell\n * lot of options there), if you use Debounce.func() directly you'll only get\n * one instance of Debounce. Which means that if you have two instances of your\n * \"object\" at once then they are going to conflict and this is going to cause\n * trouble.\n *\n * This is then a convenience class that will automatically create a new\n * instance every time the calling \"this\" changes. The instance will be added\n * as a property to \"this\" so it can be retrieved by further calls.\n *\n * @param wait {number} Milliseconds to wait before running\n * @param prop {string} Name of the property to store the Debounce instance\n *                      into\n * @constructor\n */\nexport function ObjectDebounce(\n    {\n        wait = DEFAULT_WAIT,\n        prop = DEFAULT_PROP,\n    } = {},\n) {\n    const self = this;\n\n    /**\n     * Wrapper around Debounce.func() that will automatically handle Debounce\n     * instances.\n     *\n     * @param validate {function}\n     * @param prepare {function}\n     * @param run {function}\n     * @param success {function}\n     * @param failure {function}\n     * @param cleanup {function}\n     * @returns {function(): *}\n     */\n    self.func = function ({\n        validate,\n        prepare,\n        run,\n        success,\n        failure,\n        cleanup,\n    }) {\n        return function () {\n            if (!this[prop]) {\n                this[prop] = new Debounce({wait});\n            }\n\n            const deb = this[prop];\n            const func = deb.func({\n                validate,\n                prepare,\n                run,\n                success,\n                failure,\n                cleanup,\n            });\n\n            return func.apply(this, arguments);\n        };\n    };\n}\n","import {Debounce, ObjectDebounce} from './debounce.js';\n\nexport {\n    Debounce,\n    ObjectDebounce,\n};\n"],"sourceRoot":""}