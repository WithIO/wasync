{"version":3,"sources":["webpack://wasync/webpack/universalModuleDefinition","webpack://wasync/webpack/bootstrap","webpack://wasync/./src/index.js","webpack://wasync/./src/debounce.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_debounce","_ref5","arguments","length","undefined","_ref5$wait","wait","DEFAULT_WAIT","_ref5$prop","prop","DEFAULT_PROP","func","_ref6","validate","prepare","run","success","failure","cleanup","Debounce","deb","apply","INACTIVE","WAITING","RUNNING","_ref$wait","state","next","timeout","_ref2","Error","stack","args","hooks","params","_ref3","this_","v","_ref4","clearTimeout","setTimeout","prom","_stack$hooks","Promise","resolve","e","reject","then","catch","finally"],"mappings":"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","file":"wasync.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wasync\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wasync\"] = factory();\n\telse\n\t\troot[\"wasync\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {Debounce, ObjectDebounce} from './debounce.js';\n\nexport {\n    Debounce,\n    ObjectDebounce,\n};\n","const DEFAULT_WAIT = 300;\nconst DEFAULT_PROP = '$wasyncDebounce';\n\nconst INACTIVE = 1;\nconst WAITING = 2;\nconst RUNNING = 3;\n\n\n/**\n * Implements the Async Debounce pattern.\n *\n * It helps you call asynchronous functions only once at a time.\n *\n * See the README\n *\n * @param wait {number} Milliseconds to wait before running\n * @constructor\n */\nexport function Debounce({wait = DEFAULT_WAIT} = {}) {\n    const self = this;\n\n    self.state = INACTIVE;\n    self.next = undefined;\n    self.timeout = null;\n\n    /**\n     * Generates an asynchronously debounced function\n     *\n     * @param validate {function} Validation function. If the return value is\n     *                            false-ish then the operation is canceled,\n     *                            otherwise the return value is passed as first\n     *                            parameter of run()\n     * @param prepare {function} Immediately invoked in order to prepare the\n     *                           UI for the imminent load (like enable the\n     *                           loader)\n     * @param run {function} The function that does the action. It can return\n     *                       a promise. It will be called with the output of\n     *                       validate() after wait milliseconds\n     * @param success {function} Called with the value returned/resolved by\n     *                           run() in case of success\n     * @param failure {function} Called with the exception/rejection value\n     *                           raised by run()\n     * @param cleanup {function} Does the opposite of prepare(), when all\n     *                           is finished\n     * @returns {Function} Returned function is a composition of all provided\n     *                     hooks, in such a way that each of the hook is called\n     *                     exactly when it should be (according to the logic\n     *                     explained in the README).\n     */\n    self.func = function ({\n        validate,\n        prepare,\n        run,\n        success,\n        failure,\n        cleanup,\n    }) {\n        if (!run) {\n            throw new Error(\n                '\"run\" function is not defined! That is the point of this '\n                + 'Debounce class, so you probably are doing something wrong',\n            );\n        }\n\n        return function () {\n            const stack = {\n                this: this,\n                args: arguments,\n                hooks: {\n                    validate,\n                    prepare,\n                    run,\n                    success,\n                    failure,\n                    cleanup,\n                },\n            };\n\n            stack.params = self.validate(stack);\n\n            if (!stack.params) {\n                return;\n            }\n\n            if (self.state === INACTIVE) {\n                self.prepare(stack);\n            }\n\n            self.next = stack;\n\n            if (self.state !== RUNNING) {\n                self.wait();\n            }\n        };\n    };\n\n    /**\n     * Runs the validation hook. If no hook is provided then just return an\n     * empty object.\n     *\n     * @private\n     * @param validate {function|undefined} Validation hook\n     * @param this_ {object} Object to bind the validation hook to\n     * @param args {array} Arguments to call the function with\n     */\n    self.validate = function ({hooks: {validate}, this: this_, args}) {\n        let v = {};\n\n        if (validate) {\n            v = validate.apply(this_, args);\n        }\n\n        return v;\n    };\n\n    /**\n     * Runs the prepare hook, if defined\n     *\n     * @private\n     * @param prepare {function|undefined} Prepare hook\n     * @param this_ {object} Object to bind the prepare hook to\n     */\n    self.prepare = function ({hooks: {prepare}, this: this_}) {\n        if (prepare) {\n            prepare.apply(this_);\n        }\n    };\n\n    /**\n     * Go into waiting state and call the run function after the given amount\n     * of time. If a timeout was already running, cancel it.\n     *\n     * @private\n     */\n    self.wait = function () {\n        self.state = WAITING;\n\n        clearTimeout(self.timeout);\n        self.timeout = setTimeout(function () {\n            self.run();\n        }, wait);\n    };\n\n    /**\n     * Runs the run hook, wait for the result and then trigger the finishing\n     * sequence (re-run if new run available, otherwise success/failure hooks\n     * then cleanup).\n     *\n     * It is expected that the run hook might not always return a Promise, or\n     * might just return a Promise-like but with not the exact API we need. For\n     * this reason, it passes through Promise.resolve()/Promise.reject().\n     *\n     * @private\n     */\n    self.run = function () {\n        self.state = RUNNING;\n\n        const stack = this.next;\n        const {\n            this: this_,\n            params,\n            hooks: {\n                run,\n                success,\n                failure,\n                cleanup,\n            },\n        } = stack;\n\n        let prom;\n\n        try {\n            prom = Promise.resolve(run.call(this_, params));\n        } catch (e) {\n            prom = Promise.reject(e);\n        }\n\n        prom\n            .then(function () {\n                if (success) {\n                    success.apply(this_, arguments);\n                }\n            })\n            .catch(function () {\n                if (failure) {\n                    failure.apply(this_, arguments);\n                }\n            })\n            .finally(() => {\n                if (self.next === stack) {\n                    try {\n                        if (cleanup) {\n                            cleanup.apply(this_);\n                        }\n                    } finally {\n                        self.state = INACTIVE;\n                    }\n                } else {\n                    setTimeout(() => self.run(), 0);\n                }\n            });\n    };\n}\n\n\n/**\n * Independently of how you define your \"classes\" in JS ('cause you got a hell\n * lot of options there), if you use Debounce.func() directly you'll only get\n * one instance of Debounce. Which means that if you have two instances of your\n * \"object\" at once then they are going to conflict and this is going to cause\n * trouble.\n *\n * This is then a convenience class that will automatically create a new\n * instance every time the calling \"this\" changes. The instance will be added\n * as a property to \"this\" so it can be retrieved by further calls.\n *\n * @param wait {number} Milliseconds to wait before running\n * @param prop {string} Name of the property to store the Debounce instance\n *                      into\n * @constructor\n */\nexport function ObjectDebounce(\n    {\n        wait = DEFAULT_WAIT,\n        prop = DEFAULT_PROP,\n    } = {},\n) {\n    const self = this;\n\n    /**\n     * Wrapper around Debounce.func() that will automatically handle Debounce\n     * instances.\n     *\n     * @param validate {function}\n     * @param prepare {function}\n     * @param run {function}\n     * @param success {function}\n     * @param failure {function}\n     * @param cleanup {function}\n     * @returns {function(): *}\n     */\n    self.func = function ({\n        validate,\n        prepare,\n        run,\n        success,\n        failure,\n        cleanup,\n    }) {\n        return function () {\n            if (!this[prop]) {\n                this[prop] = new Debounce({wait});\n            }\n\n            const deb = this[prop];\n            const func = deb.func({\n                validate,\n                prepare,\n                run,\n                success,\n                failure,\n                cleanup,\n            });\n\n            return func.apply(this, arguments);\n        };\n    };\n}\n"],"sourceRoot":""}